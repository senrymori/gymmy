---
alwaysApply: true
---

# Code Style Rules

These rules MUST be followed by the AI when generating, editing, or refactoring code in this repository.
If there is a conflict, these rules take priority over default behavior.

## TypeScript

- Всегда используй TypeScript, избегай `any` где это возможно
- Используй строгую типизацию, явно указывай типы для пропсов, состояний и функций
- Для React компонентов используй функциональные компоненты с TypeScript
- Используй интерфейсы для пропсов компонентов, типы для утилит и сложных структур
- Применяй `type` для union types, `interface` для объектов и компонентов
- Если код пишется не внутри класса/компонента, то создавай function verbName (вместо стрелочных функций)
- Если создаешь переменную с типом `Record`, то нейминг должен начинаться с `record`, пример `const recordSize: Record<number, >`

## Naming Conventions

- **Компоненты**: PascalCase (`UserProfile.tsx`, `WorkoutCard.tsx`)
- **Хуки**: camelCase с префиксом `use` (`useAuth.ts`, `useWorkoutData.ts`)
- **Утилиты и константы**: camelCase (`formatDate.ts`, `apiClient.ts`)
- **Константы из env**: UPPER_SNAKE_CASE (`API_BASE_URL`)
- **Обычные константы**: camelCase (`isIos`, `maxImageLimit`)
- **Enum константы**: PascalCaseEnum (`isIos`, `maxImageLimit`)
- **Файлы**: соответствуют экспортируемому элементу (компонент = PascalCase, хук = camelCase с use), если несколько экспортных элементов, то нейминг по общему содержимому и контексту, где файл создается
- **Папки**: kebab-case для многословных названий (`personal-training/`, `workout-rework/`)

## React Native Components

- Когда объявляешь компонент, указывай ему сразу типа `FC` из react (пример: `const ComponentName: FC<Props> = functions(props) {}`)
- Если компонент ожидает только children (часто в контекстах), то не надо создавать для него отдельный тип, можешь использовать PropsWithChildren (пример: `Provider: FC<PropsWithChildren> = function ({ children })`)
- Используй функциональные компоненты с хуками
- Разделяй логику и представление: хуки для логики, компоненты для UI
- Используй `StyleSheet.create` для стилей, избегай inline стилей кроме динамических значений (стили локальные для компонента не выносятся в отдельный файл)
- Для условного рендеринга используй тернарные операторы или `&&`, избегай сложных вложенных условий
- Используй `memo` для оптимизации только когда это действительно нужно
- Не используй `React.memo` импортируй сразу `memo` из react библиотеки
- Если возвращаемый JSX компонента привышает 100 строк, то выноси содержимое в компоненты
- Не делай такую деструкторизацию в пропсах: `function ({ example1, example2, ...rest })`, лучше делай так `const { example1, example2, ...rest } = props`
- Не используй строковые литералы в JSX без фигурных скобок: вместо `<Example field="test">` нужно всегда писать `<Example field={'test'}`. Это правило распространяется на все props, передаваемые компонентам: значения всегда должны быть внутри фигурных скобок.

## Imports

- Группируй импорты: сначала внешние библиотеки, потом внутренние модули
- Используй абсолютные импорты через алиасы (если настроены) или относительные от `src/`
- Порядок: React/React Native → сторонние библиотеки → внутренние компоненты → утилиты → типы → константы
- Никогда не исользуй default exports, старайся использовать named exports

## Code Formatting

- Используй форматирование Prettier

## Comments

- Комментарии строго на английском языке
- Используй комментарии для объяснения "почему", а не "что" (за исключением больших секций с общим смыслом в 10+ строк)
- JSDoc комментарии для публичных функций и компонентов

## Error Handling

- Используй try-catch для асинхронных операций
- Обрабатывай ошибки явно, не проглатывай их (через console.error, а не console.log)
- Используй типизированные ошибки где возможно
- Логируй ошибки в development режиме

## Async/Await

- Предпочитай async/await вместо Promise chains
- Используй Promise.all для параллельных запросов
- Обрабатывай loading и error состояния явно

## State Management

- Используй useState для локального состояния компонента
- Используй useReducer для сложного локального состояния
- Используй tanstack query для получения ассинхронных данных
- Для глобального состояния используй Context API или выбранную библиотеку (если есть)
- Избегай prop drilling, используй Context или композицию компонентов

## Performance

- Используй useMemo и useCallback только когда есть реальная необходимость
- Избегай создания объектов и функций в render без мемоизации если они передаются как пропсы
- Используй FlatList для длинных списков, не ScrollView
- Оптимизируй изображения, используй подходящие форматы и размеры (используй работу с кэшем и предзагрузкой с отображением loader'а при подгрузки)
